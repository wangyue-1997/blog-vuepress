(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{389:function(T,_,t){"use strict";t.r(_);var v=t(3),a=Object(v.a)({},(function(){var T=this,_=T.$createElement,t=T._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":T.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[T._v("#")]),T._v(" 前言")]),T._v(" "),t("p",[T._v("HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语义兼容的基础上，进一步减少了网络的延迟。实现低延迟高吞吐量。对于前端开发者而言，减少了优化工作。本文将重点围绕以下几点新特性的作用、工作过程以及如何更出色的完成了优化工作来介绍HTTP2.0")]),T._v(" "),t("ul",[t("li",[T._v("二进制分帧")]),T._v(" "),t("li",[T._v("首部压缩")]),T._v(" "),t("li",[T._v("多路复用")]),T._v(" "),t("li",[T._v("请求优先级")]),T._v(" "),t("li",[T._v("服务器推送")])]),T._v(" "),t("h2",{attrs:{id:"一、介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、介绍"}},[T._v("#")]),T._v(" 一、介绍")]),T._v(" "),t("p",[T._v("HTTP/2是HTTP协议自1999年HTTP1.1发布后的首个更新，主要基于SPDY协议。")]),T._v(" "),t("h3",{attrs:{id:"_1-1-什么是spdy协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-什么是spdy协议"}},[T._v("#")]),T._v(" 1.1 什么是SPDY协议")]),T._v(" "),t("p",[T._v("SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。")]),T._v(" "),t("h3",{attrs:{id:"_1-2-http1-x的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-http1-x的缺点"}},[T._v("#")]),T._v(" 1.2 HTTP1.X的缺点")]),T._v(" "),t("p",[T._v("任何事物的更新都是为了弥补或修复上个版本的某些问题，那么我们来看看HTTP1.x都有哪些缺点以至于我们要使用HTTP2.0。")]),T._v(" "),t("ol",[t("li",[T._v("HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟")]),T._v(" "),t("li",[T._v("单向请求，只能由客户端发起")]),T._v(" "),t("li",[T._v("请求报文与响应报文首部信息冗余量大")]),T._v(" "),t("li",[T._v("据未压缩，导致数据的传输量大")])]),T._v(" "),t("h2",{attrs:{id:"二、二进制分帧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、二进制分帧"}},[T._v("#")]),T._v(" 二、二进制分帧")]),T._v(" "),t("p",[T._v("在不改变HTTP1.x的语义、方法、状态码、URL以及首部字段的情况下，HTTP2.0是怎样突破HTTP1.1的性能限制，改进传输性能，实现低延迟高吞吐量的呢？关键之一就是在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。")]),T._v(" "),t("ul",[t("li",[T._v("帧：HTTP2.0通信的最小单位，所有帧都共享一个8字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识符，帧承载着特定类型的数据，如HTTP首部、负荷、等等。")]),T._v(" "),t("li",[T._v("消息：比帧大的通讯单位，是指逻辑上的HTTP消息，比如请求、响应等。由一个或多个帧组成。")]),T._v(" "),t("li",[T._v("流：比消息大的通讯单位。是TCP连接中的一个虚拟通道，可以承载双向的消息。每个流都有一个唯一的整数标识符。")])]),T._v(" "),t("p",[T._v("HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。")]),T._v(" "),t("p",[T._v("在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。")]),T._v(" "),t("p",[t("img",{attrs:{src:"/blog-vuepress/2020/1022/20190802162333949.png",alt:""}})]),T._v(" "),t("p",[T._v("为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。")]),T._v(" "),t("h3",{attrs:{id:"三、首部压缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、首部压缩"}},[T._v("#")]),T._v(" 三、首部压缩")]),T._v(" "),t("p",[T._v("HTTP1.1并不支持HTTP首部压缩，为此SPDY和HTTP2.0出现了。SPDY是用的是DEFLATE算法，而HTTP2.0则使用了专门为首部压缩设计的HPACK算法。")]),T._v(" "),t("p",[T._v("HTTP每次通讯（请求或响应）都会携带首部信息用于描述资源属性。")]),T._v(" "),t("p",[T._v("在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。")]),T._v(" "),t("p",[T._v("在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。")]),T._v(" "),t("h2",{attrs:{id:"四、多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、多路复用"}},[T._v("#")]),T._v(" 四、多路复用")]),T._v(" "),t("p",[T._v("在HTTP1.x中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。")]),T._v(" "),t("p",[T._v("HTTP2.0中,基于二进制分帧层，HTTP2.0可以在共享TCP连接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。 通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。")]),T._v(" "),t("h2",{attrs:{id:"五、请求优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、请求优先级"}},[T._v("#")]),T._v(" 五、请求优先级")]),T._v(" "),t("p",[T._v("把HTTP消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。")]),T._v(" "),t("h2",{attrs:{id:"六、服务器推送"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、服务器推送"}},[T._v("#")]),T._v(" 六、服务器推送")]),T._v(" "),t("p",[T._v("HTTP2.0新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。")]),T._v(" "),t("p",[T._v("服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。如下图，客户端请求stream 1(/page.html)。服务端在返回stream 1的消息的同时推送了stream 2(/script.js)和stream 4(/style.css)")]),T._v(" "),t("p",[t("img",{attrs:{src:"/blog-vuepress/2020/1022/20190802165438943.jpg",alt:""}})]),T._v(" "),t("p",[T._v("服务端推送是一种在客户端请求之前发送数据的机制。在HTTP2.0中，服务器可以对一个客户端的请求发送多个响应。如果一个请求是由你的主页发送的，服务器可能会响应主页内容、logo以及样式表，因为他知道客户端会用到这些东西。这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。")]),T._v(" "),t("p",[T._v("推送的缺点：所有推送的资源都必须遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方的确认才行。")])])}),[],!1,null,null,null);_.default=a.exports}}]);