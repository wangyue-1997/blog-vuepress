(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{354:function(v,a,t){"use strict";t.r(a);var _=t(3),r=Object(_.a)({},(function(){var v=this,a=v.$createElement,t=v._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("blockquote",[t("p",[v._v("JavaScript引擎是执行JavaScript代码的程序或解释器。javaScript引擎可以实现为标准解释器或即时编译器，它以某种形式将JavaScript编译为字节码。")])]),v._v(" "),t("h3",{attrs:{id:"常见的js引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的js引擎"}},[v._v("#")]),v._v(" 常见的js引擎")]),v._v(" "),t("ul",[t("li",[v._v("V8 - 开源，由Google开发，用C ++编写")]),v._v(" "),t("li",[v._v("Rhin- 由Mozilla基金会开源，完全用Java开发")]),v._v(" "),t("li",[v._v("SpiderMonkey 第一个JavaScript引擎，Netscape Navigator，Firefox")]),v._v(" "),t("li",[v._v("JavaScriptCore 苹果公司为Safari开发")]),v._v(" "),t("li",[v._v("Chakra** (JavaScript) Microsoft IE9-IE11")]),v._v(" "),t("li",[v._v("JerryScript 一个物联网的轻量级引擎")])]),v._v(" "),t("h3",{attrs:{id:"v8引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎"}},[v._v("#")]),v._v(" V8引擎")]),v._v(" "),t("p",[t("img",{attrs:{src:"/blog-vuepress/2020/v8.png",alt:""}})]),v._v(" "),t("p",[v._v("V8是被设计用来提高网页浏览器内部JavaScript执行的性能，那么如何提高性能呢？")]),v._v(" "),t("p",[v._v("为了提高性能，v8会把js代码转换为高效的机器码，而不在是依赖于解释器去执行。v8引入了JIT在运行时把js代码进行转换为机器码。这里的主要区别在于"),t("strong",[v._v("V8不生成字节码或任何中间代码")]),v._v("。")]),v._v(" "),t("p",[v._v("v8充分多进程，主进程负责获取代码，编译生成机器码，有专门负责优化的进程，，还有一个监控进程负责分析那些代码执行比较慢，以遍Crankshaft 做优化，最后还有一个就是GC进程，负责内存垃圾回收。")]),v._v(" "),t("h4",{attrs:{id:"v8的具体优化方案："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8的具体优化方案："}},[v._v("#")]),v._v(" v8的具体优化方案：")]),v._v(" "),t("ul",[t("li",[v._v("第一个优化就是尽可能最大的内联。")])]),v._v(" "),t("p",[v._v("内联主要是通过优化被调用函数的调用栈。"),t("em",[v._v("这块理解还不是很透彻")])]),v._v(" "),t("ul",[t("li",[v._v("第二个是优化就隐藏类。")])]),v._v(" "),t("p",[v._v("js中并没有指针的概念，js的对象访问就是基于隐藏类的。")]),v._v(" "),t("p",[t("strong",[v._v("隐藏类转换取决于将属性添加到对象的顺序")])]),v._v(" "),t("ul",[t("li",[v._v("第三个是内联缓存")])]),v._v(" "),t("p",[v._v("内联缓存依赖于对相同方法的重复调用倾向于在相同类型的对象上发生的观察。")]),v._v(" "),t("p",[v._v("V8维护一个在最近的方法调用中作为参数传递的对象类型的缓存，并使用这些信息来预测将来作为参数传递的对象的类型。如果V8能够对传递给方法的对象的类型做出一个很好的假设，那么它可以绕过确定如何访问对象属性的过程，而是使用以前查找存储的信息到对象的隐藏类。")]),v._v(" "),t("p",[v._v("V8在执行一个对象的方法时，会通过查找隐藏类确定偏移量，然后去执行，在两次成功调用后，V8会假定对象不变，再次调用时直接利用偏移量去访问，而不在去做隐藏类查找。这极大的提升了运行速度，这也是为什么在初始化对象时，最好保证同样的顺序。")]),v._v(" "),t("ul",[t("li",[v._v("第四个是Compilation to machine code")])]),v._v(" "),t("p",[v._v("V8之前的优化，是基于某种假设。如果假设失败，v8会启动一种为 deoptimization 的行为，重新去分析。这种行为的成本很高，所以要尽量避免。")]),v._v(" "),t("ul",[t("li",[v._v("第五个是垃圾回收机制")])]),v._v(" "),t("p",[v._v("对于垃圾收集，V8采用了传统的分代式扫描方式来清理老一代。标记阶段应该停止JavaScript的执行。为了控制GC成本并使执行更加稳定，V8使用了渐进式标记：而不是走遍整个堆，试图标记每一个可能的对象，它只走一部分堆，然后恢复正常执行。")]),v._v(" "),t("h4",{attrs:{id:"如何编写优化的javascript呢？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何编写优化的javascript呢？"}},[v._v("#")]),v._v(" 如何编写优化的JavaScript呢？")]),v._v(" "),t("p",[v._v("1.总是以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。在实例化之后向对象添加属性将强制隐藏类更改，并放慢为以前隐藏类优化的所有方法。相反，在其构造函数中分配所有对象的属性")]),v._v(" "),t("p",[v._v("2.重复执行相同方法的代码将比仅执行一次（由于内联高速缓存）执行许多不同方法的代码运行得更快。")]),v._v(" "),t("p",[v._v("3.避免键数不是增量数的稀疏数组。稀疏数组中没有每个元素都是哈希表。这种阵列中的元素访问费用较高。另外，尽量避免预分配大型数组。随着你的成长，你的成长会更好。最后，不要删除数组中的元素。")]),v._v(" "),t("p",[v._v("4.v8用32位的对象和数字。由于它的31位，它使用了一点来知道它是一个对象（flag = 1）还是一个称为SMI（SMall Integer）的整数（flag = 0）。然后，如果一个数字值大于31位，V8会把这个数字装箱，把它变成一个double，并创建一个新的对象，把数字放在里面。尽可能使用31位有符号数字，以避免昂贵的拳击操作成JS对象")])])}),[],!1,null,null,null);a.default=r.exports}}]);