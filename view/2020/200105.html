<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题 | Wangyue1997&#39;s blog</title>
    <meta name="description" content="While the world sleeps,you dream">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/blog-vuepress/blog.ico" text="wangyue s blog">
    
    <link rel="preload" href="/blog-vuepress/assets/css/0.styles.1fbc985a.css" as="style"><link rel="preload" href="/blog-vuepress/assets/js/app.ad6e5f6e.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/3.0ace89c5.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/1.960ca73c.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/14.e482d904.js" as="script"><link rel="prefetch" href="/blog-vuepress/assets/js/10.a90ebd51.js"><link rel="prefetch" href="/blog-vuepress/assets/js/11.912abaf2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/12.32caf163.js"><link rel="prefetch" href="/blog-vuepress/assets/js/13.c5540b04.js"><link rel="prefetch" href="/blog-vuepress/assets/js/15.e57f7073.js"><link rel="prefetch" href="/blog-vuepress/assets/js/16.9ac53183.js"><link rel="prefetch" href="/blog-vuepress/assets/js/17.67dea5bc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/18.7638b59c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/19.bae5be35.js"><link rel="prefetch" href="/blog-vuepress/assets/js/20.8eb59042.js"><link rel="prefetch" href="/blog-vuepress/assets/js/21.ea19fdc1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/22.f22d9f9c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/23.ef326b1f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/24.aa790226.js"><link rel="prefetch" href="/blog-vuepress/assets/js/25.e73713c5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/26.bc5442dd.js"><link rel="prefetch" href="/blog-vuepress/assets/js/27.dae68ca7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/28.f6399f4d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/29.9d42226b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/30.efbf69a0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/31.1818543d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/32.8a62a595.js"><link rel="prefetch" href="/blog-vuepress/assets/js/33.74ef7a4a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/34.145070ac.js"><link rel="prefetch" href="/blog-vuepress/assets/js/35.3bc46d1a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/36.b9473131.js"><link rel="prefetch" href="/blog-vuepress/assets/js/37.44ad30d2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/38.bcb138fc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/39.1e15ba67.js"><link rel="prefetch" href="/blog-vuepress/assets/js/4.a0136700.js"><link rel="prefetch" href="/blog-vuepress/assets/js/40.29f557b4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/41.24f747d3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/42.24329a10.js"><link rel="prefetch" href="/blog-vuepress/assets/js/43.08214c24.js"><link rel="prefetch" href="/blog-vuepress/assets/js/44.afac1e79.js"><link rel="prefetch" href="/blog-vuepress/assets/js/45.cc1f251e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/46.1adeeac8.js"><link rel="prefetch" href="/blog-vuepress/assets/js/47.5510a45c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/48.e6b85ef6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/49.1fd5fa05.js"><link rel="prefetch" href="/blog-vuepress/assets/js/5.1d428120.js"><link rel="prefetch" href="/blog-vuepress/assets/js/50.e767d5a6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/51.03420f02.js"><link rel="prefetch" href="/blog-vuepress/assets/js/52.14a94dfc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/53.de15151f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/54.98750c56.js"><link rel="prefetch" href="/blog-vuepress/assets/js/55.2c98cb1c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/56.f900e827.js"><link rel="prefetch" href="/blog-vuepress/assets/js/57.1bddffe4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/58.f959d647.js"><link rel="prefetch" href="/blog-vuepress/assets/js/59.591f155e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/6.bce081b4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/60.d0753a06.js"><link rel="prefetch" href="/blog-vuepress/assets/js/61.009974ca.js"><link rel="prefetch" href="/blog-vuepress/assets/js/62.9e4ceded.js"><link rel="prefetch" href="/blog-vuepress/assets/js/63.36be13fa.js"><link rel="prefetch" href="/blog-vuepress/assets/js/64.c2eeb7c1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/65.15bd2f22.js"><link rel="prefetch" href="/blog-vuepress/assets/js/66.642c7212.js"><link rel="prefetch" href="/blog-vuepress/assets/js/67.da88e6a0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/68.9f51ed59.js"><link rel="prefetch" href="/blog-vuepress/assets/js/69.66d44712.js"><link rel="prefetch" href="/blog-vuepress/assets/js/7.91169816.js"><link rel="prefetch" href="/blog-vuepress/assets/js/70.fda72f97.js"><link rel="prefetch" href="/blog-vuepress/assets/js/71.248b4b52.js"><link rel="prefetch" href="/blog-vuepress/assets/js/72.a104cef7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/73.d1544cf0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/74.61881079.js"><link rel="prefetch" href="/blog-vuepress/assets/js/75.a58a58bb.js"><link rel="prefetch" href="/blog-vuepress/assets/js/76.6db58720.js"><link rel="prefetch" href="/blog-vuepress/assets/js/77.9a2d9a90.js"><link rel="prefetch" href="/blog-vuepress/assets/js/78.981443c1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/79.77d7acd3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/8.7869fd35.js"><link rel="prefetch" href="/blog-vuepress/assets/js/80.9277ed16.js"><link rel="prefetch" href="/blog-vuepress/assets/js/9.64dfb633.js">
    <link rel="stylesheet" href="/blog-vuepress/assets/css/0.styles.1fbc985a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="theme-container" data-v-319dd33c><div data-v-319dd33c><div id="loader-wrapper" class="loading-wrapper" data-v-4b73742e data-v-319dd33c data-v-319dd33c><div class="loader-main" data-v-4b73742e><div data-v-4b73742e></div><div data-v-4b73742e></div><div data-v-4b73742e></div><div data-v-4b73742e></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-1e2a0cc0 data-v-319dd33c data-v-319dd33c><h3 class="title" style="display:none;" data-v-1e2a0cc0 data-v-1e2a0cc0>Wangyue1997's blog</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-1e2a0cc0 data-v-1e2a0cc0><input type="password" value="" data-v-1e2a0cc0> <span data-v-1e2a0cc0>Konck! Knock!</span> <button data-v-1e2a0cc0>OK</button></label> <div class="footer" style="display:none;" data-v-1e2a0cc0 data-v-1e2a0cc0><span data-v-1e2a0cc0><i class="iconfont reco-theme" data-v-1e2a0cc0></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-1e2a0cc0>vuePress-theme-reco</a></span> <span data-v-1e2a0cc0><i class="iconfont reco-copyright" data-v-1e2a0cc0></i> <a data-v-1e2a0cc0><span data-v-1e2a0cc0>wangshanjian</span>
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-319dd33c><header class="navbar" data-v-319dd33c><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog-vuepress/" class="home-link router-link-active"><img src="/blog-vuepress/profile.jpg" alt="Wangyue1997's blog" class="logo"> <span class="site-name">Wangyue1997's blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-vuepress/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/frontEnd/" class="nav-link"><i class="iconfont undefined"></i>
  frontEnd
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/tools/" class="nav-link"><i class="iconfont undefined"></i>
  tools
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/Interview questions/" class="nav-link"><i class="iconfont undefined"></i>
  Interview questions
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/article/" class="nav-link"><i class="iconfont undefined"></i>
  article
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/afterend/" class="nav-link"><i class="iconfont undefined"></i>
  afterend
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/algorithm/" class="nav-link"><i class="iconfont undefined"></i>
  algorithm
</a></li></ul></div></div><div class="nav-item"><a href="/blog-vuepress/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/blog-vuepress/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.csdn.net/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CNSD
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-319dd33c></div> <aside class="sidebar" data-v-319dd33c><div class="personal-info-wrapper" data-v-6c8ffc9c><img src="/blog-vuepress/profile.jpg" alt="author-avatar" class="personal-img" data-v-6c8ffc9c> <h3 class="name" data-v-6c8ffc9c>
    wangshanjian
  </h3> <div class="num" data-v-6c8ffc9c><div data-v-6c8ffc9c><h3 data-v-6c8ffc9c>69</h3> <h6 data-v-6c8ffc9c>文章</h6></div> <div data-v-6c8ffc9c><h3 data-v-6c8ffc9c>15</h3> <h6 data-v-6c8ffc9c>标签</h6></div></div> <hr data-v-6c8ffc9c></div> <nav class="nav-links"><div class="nav-item"><a href="/blog-vuepress/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/frontEnd/" class="nav-link"><i class="iconfont undefined"></i>
  frontEnd
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/tools/" class="nav-link"><i class="iconfont undefined"></i>
  tools
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/Interview questions/" class="nav-link"><i class="iconfont undefined"></i>
  Interview questions
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/article/" class="nav-link"><i class="iconfont undefined"></i>
  article
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/afterend/" class="nav-link"><i class="iconfont undefined"></i>
  afterend
</a></li><li class="dropdown-item"><!----> <a href="/blog-vuepress/categories/algorithm/" class="nav-link"><i class="iconfont undefined"></i>
  algorithm
</a></li></ul></div></div><div class="nav-item"><a href="/blog-vuepress/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/blog-vuepress/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.csdn.net/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  CNSD
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/view/2020/200105.html#一、html" class="sidebar-link">一、html</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_1-doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="sidebar-link">1.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_2-html与xhtml二者的区别" class="sidebar-link">2.HTML与XHTML二者的区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_3-如何选择图片格式" class="sidebar-link">3.如何选择图片格式</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_4-html5的新特性" class="sidebar-link">4.html5的新特性</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_5-px、em、rem区别介绍" class="sidebar-link">5.px、em、rem区别介绍</a></li></ul></li><li><a href="/blog-vuepress/view/2020/200105.html#二-、css" class="sidebar-link">二 、css</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_1-浮动和清除浮动" class="sidebar-link">1.浮动和清除浮动</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_2-css-选择符有哪些" class="sidebar-link">2.CSS 选择符有哪些</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_3-css3中新添加的特性" class="sidebar-link">3.CSS3中新添加的特性</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_4-canvas性能优化" class="sidebar-link">4.canvas性能优化</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_5-什么是bfc，可以解决什么问题" class="sidebar-link">5.什么是BFC，可以解决什么问题</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_6-css实现一个三角形" class="sidebar-link">6.css实现一个三角形</a></li></ul></li><li><a href="/blog-vuepress/view/2020/200105.html#三、javascript" class="sidebar-link">三、javaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_1-xml和-json的区别" class="sidebar-link">1.XML和 JSON的区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_2-作用域链的理解" class="sidebar-link">2.作用域链的理解</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_3-创建ajax过程" class="sidebar-link">3.创建ajax过程</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_4-对前端模块化的认识" class="sidebar-link">4.对前端模块化的认识</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_5-javascript垃圾回收方法" class="sidebar-link">5.Javascript垃圾回收方法</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_6-栈和队列、栈和堆的区别" class="sidebar-link">6.栈和队列、栈和堆的区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_7-快速排序的思想并实现一个快排" class="sidebar-link">7.快速排序的思想并实现一个快排</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_8-javascript对象的几种创建方式" class="sidebar-link">8.javascript对象的几种创建方式</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_9-javascript继承的6种方法" class="sidebar-link">9.javascript继承的6种方法</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_10-闭包的理解" class="sidebar-link">10.闭包的理解</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_11-cookie-和session-的区别" class="sidebar-link">11.cookie 和session 的区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_12-virtual-dom-的优势在哪里" class="sidebar-link">12.Virtual Dom 的优势在哪里</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_13-node中的进程与线程" class="sidebar-link">13.Node中的进程与线程</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_14-隐式类型转换" class="sidebar-link">14.隐式类型转换</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_15-判断-js-类型的方式" class="sidebar-link">15.判断 js 类型的方式</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_16-浏览器与node的事件循环有何区别" class="sidebar-link">16.浏览器与Node的事件循环有何区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_17-前端性能优化" class="sidebar-link">17.前端性能优化</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_18-es6特性" class="sidebar-link">18.ES6特性</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_19-promise内部实现原理" class="sidebar-link">19.Promise内部实现原理</a></li></ul></li><li><a href="/blog-vuepress/view/2020/200105.html#四、http" class="sidebar-link">四、http</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_1-tcp传输的三次握手四次挥手策略" class="sidebar-link">1.TCP传输的三次握手四次挥手策略</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_2-tcp和udp的区别" class="sidebar-link">2.TCP和UDP的区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_3-web-worker-和websocket" class="sidebar-link">3.Web  Worker 和webSocket</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_4-http和https" class="sidebar-link">4.HTTP和HTTPS</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_5-为什么-https-安全" class="sidebar-link">5. 为什么 HTTPS 安全</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_6-什么是etag" class="sidebar-link">6.什么是Etag</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_7-expires和cache-control" class="sidebar-link">7.Expires和Cache-Control</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_8-http-2-0" class="sidebar-link">8.Http 2.0</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_9-http状态码" class="sidebar-link">9.HTTP状态码</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_10-如何解决跨域问题" class="sidebar-link">10.如何解决跨域问题</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_11-一个-tcp-连接能发几个-http-请求" class="sidebar-link">11. 一个 tcp 连接能发几个 http 请求</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_12-怎么与服务端保持连接" class="sidebar-link">12.怎么与服务端保持连接</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_13-tcp有哪些手段保证可靠交付" class="sidebar-link">13.TCP有哪些手段保证可靠交付</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_14-web如何应对流量劫持" class="sidebar-link">14.Web如何应对流量劫持</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_15-jwt的优缺点" class="sidebar-link">15.JWT的优缺点</a></li></ul></li><li><a href="/blog-vuepress/view/2020/200105.html#五、browser" class="sidebar-link">五、browser</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_1-浏览器兼容问题" class="sidebar-link">1.浏览器兼容问题</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_2-常见web安全及防护原理" class="sidebar-link">2.常见web安全及防护原理</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_3-列举ie-与其他浏览器不一样的特性" class="sidebar-link">3.列举IE 与其他浏览器不一样的特性</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_4-浏览器的线程有哪些" class="sidebar-link">4.浏览器的线程有哪些</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_5-如何加快首屏渲染" class="sidebar-link">5.如何加快首屏渲染</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_6-输入url后发生了什么" class="sidebar-link">6.输入url后发生了什么</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_7-性能优化从哪些方面入手" class="sidebar-link">7.性能优化从哪些方面入手</a></li></ul></li><li><a href="/blog-vuepress/view/2020/200105.html#六、vue" class="sidebar-link">六、Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_1-vue-双向绑定原理" class="sidebar-link">1.Vue 双向绑定原理</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_2-vue-的响应式系统" class="sidebar-link">2.Vue 的响应式系统</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_3-虚拟-dom-实现原理" class="sidebar-link">3.虚拟 DOM 实现原理</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_4-vue-首屏加载优化" class="sidebar-link">4.vue 首屏加载优化</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_5-vue的生命周期" class="sidebar-link">5.vue的生命周期</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_6-vue的nexttick实现原理以及应用场景" class="sidebar-link">6.vue的nextTick实现原理以及应用场景</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_7-vue3-proxy解决了哪些问题" class="sidebar-link">7.Vue3 proxy解决了哪些问题</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_8-观察者模式和发布订阅模式区别" class="sidebar-link">8.观察者模式和发布订阅模式区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_9-父子组件生命周期执行顺序" class="sidebar-link">9.父子组件生命周期执行顺序</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_10-实现指令" class="sidebar-link">10.实现指令</a></li></ul></li><li><a href="/blog-vuepress/view/2020/200105.html#七、webpack" class="sidebar-link">七、webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_1-webpack构建流程" class="sidebar-link">1. webpack构建流程</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_2-webpack的plugins实现原理" class="sidebar-link">2.webpack的plugins实现原理</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_3-webpack前端构建性能优化策略" class="sidebar-link">3.webpack前端构建性能优化策略</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_4-loader-与-plugins-的区别" class="sidebar-link">4.loader 与 plugins 的区别</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_5-常用的loader" class="sidebar-link">5.常用的loader</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_6-常用的plugins" class="sidebar-link">6.常用的plugins</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_7-编写-plugin" class="sidebar-link">7.编写 plugin</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_8-scope-hoisting-作用域提升" class="sidebar-link">8.scope hoisting (作用域提升)</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_9-tree-sharking" class="sidebar-link">9. tree sharking</a></li><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_10-热更新" class="sidebar-link">10.热更新</a></li></ul></li><li><a href="/blog-vuepress/view/2020/200105.html#八、算法" class="sidebar-link">八、算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-vuepress/view/2020/200105.html#_1-top-k问题" class="sidebar-link">1. top-K问题</a></li></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-1e2a0cc0 data-v-319dd33c><h3 class="title" style="display:none;" data-v-1e2a0cc0 data-v-1e2a0cc0>前端面试题</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-1e2a0cc0 data-v-1e2a0cc0><input type="password" value="" data-v-1e2a0cc0> <span data-v-1e2a0cc0>Konck! Knock!</span> <button data-v-1e2a0cc0>OK</button></label> <div class="footer" style="display:none;" data-v-1e2a0cc0 data-v-1e2a0cc0><span data-v-1e2a0cc0><i class="iconfont reco-theme" data-v-1e2a0cc0></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-1e2a0cc0>vuePress-theme-reco</a></span> <span data-v-1e2a0cc0><i class="iconfont reco-copyright" data-v-1e2a0cc0></i> <a data-v-1e2a0cc0><span data-v-1e2a0cc0>wangshanjian</span>
            
          <!---->
          2021
        </a></span></div></div> <div data-v-319dd33c><main class="page"><div class="page-title" style="display:none;"><h1>前端面试题</h1> <hr> <div data-v-484a899e><i class="iconfont reco-account" data-v-484a899e><span data-v-484a899e>wangshanjian</span></i> <i class="iconfont reco-date" data-v-484a899e><span data-v-484a899e>2020-01-05</span></i> <!----> <i class="iconfont reco-tag tags" data-v-484a899e><span class="tag-item" data-v-484a899e>
      html
    </span><span class="tag-item" data-v-484a899e>
      css
    </span><span class="tag-item" data-v-484a899e>
      javaScript
    </span><span class="tag-item" data-v-484a899e>
      http
    </span><span class="tag-item" data-v-484a899e>
      browser
    </span><span class="tag-item" data-v-484a899e>
      vue
    </span><span class="tag-item" data-v-484a899e>
      webpack
    </span><span class="tag-item" data-v-484a899e>
      algorithm
    </span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p><img src="/blog-vuepress/2020/0105/1048592-20170319163514323-799988002.jpg" alt=""></p> <h2 id="一、html"><a href="#一、html" class="header-anchor">#</a> 一、html</h2> <h3 id="_1-doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#_1-doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="header-anchor">#</a> 1.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义</h3> <ol><li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档</li> <li>严格模式的排版和 <code>JS</code> 运作模式是 以该浏览器支持的最高标准运行</li> <li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作</li> <li><code>DOCTYPE</code> 不存在或格式不正确会导致文档以混杂模式呈现</li></ol> <h3 id="_2-html与xhtml二者的区别"><a href="#_2-html与xhtml二者的区别" class="header-anchor">#</a> 2.HTML与XHTML二者的区别</h3> <ol><li>所有的标记都必须要有一个相应的结束标记</li> <li>所有标签的元素和属性的名字都必须使用小写</li> <li>所有的XML标记都必须合理嵌套</li> <li>所有的属性必须用引号&quot;&quot;括起来</li> <li>把所有&lt;和&amp;特殊符号用编码表示</li> <li>给所有属性赋一个值</li> <li>不要在注释内容中使“--”</li> <li>图片必须有说明文字</li></ol> <h3 id="_3-如何选择图片格式"><a href="#_3-如何选择图片格式" class="header-anchor">#</a> 3.如何选择图片格式</h3> <table><thead><tr><th>图片格式</th> <th>压缩方式</th> <th>透明度</th> <th>动画</th> <th>浏览器兼容</th> <th>适应场景</th></tr></thead> <tbody><tr><td>JPEG</td> <td>有损压缩</td> <td>不支持</td> <td>不支持</td> <td>所有</td> <td>复杂颜色及形状、尤其是照片</td></tr> <tr><td>GIF</td> <td>无损压缩</td> <td>支持</td> <td>支持</td> <td>所有</td> <td>简单颜色，动画</td></tr> <tr><td>PNG</td> <td>无损压缩</td> <td>支持</td> <td>不支持</td> <td>所有</td> <td>需要透明时</td></tr> <tr><td>APNG</td> <td>无损压缩</td> <td>支持</td> <td>支持</td> <td>FirefoxSafariiOS Safari</td> <td>需要半透明效果的动画</td></tr> <tr><td>WebP</td> <td>有损压缩</td> <td>支持</td> <td>支持</td> <td>ChromeOperaAndroid ChromeAndroid Browser</td> <td>复杂颜色及形状浏览器平台可预知</td></tr> <tr><td>SVG</td> <td>无损压缩</td> <td>支持</td> <td>支持</td> <td>所有（IE8以上）</td> <td>简单图形，需要良好的放缩体验需要动态控制图片特效</td></tr></tbody></table> <h3 id="_4-html5的新特性"><a href="#_4-html5的新特性" class="header-anchor">#</a> 4.html5的新特性</h3> <ul><li>添加了video，radio标签</li> <li>添加了canvas画布和svg,渲染矢量图片</li> <li>添加了一些列语义化标签header,footer,main,section,aside,nav等</li> <li>input的type值新添加了很多属性（email，url，number，range，Date pickers (date, month, week, time, datetime, datetime-local)，search，color）</li> <li>添加了地理位置定位功能 Geolocation API</li> <li>添加了web存储功能，localStorage和sessionStorage</li> <li>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本</li> <li>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能</li> <li>服务端事件推送（EventSource 对象用于接收服务器发送事件通知），所有主流浏览器均支持服务器发送事件，除了 Internet Explorer</li></ul> <h3 id="_5-px、em、rem区别介绍"><a href="#_5-px、em、rem区别介绍" class="header-anchor">#</a> 5.px、em、rem区别介绍</h3> <ol><li>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</li> <li>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸，相对于父级元素。</li> <li>rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。</li></ol> <h2 id="二-、css"><a href="#二-、css" class="header-anchor">#</a> 二 、css</h2> <h3 id="_1-浮动和清除浮动"><a href="#_1-浮动和清除浮动" class="header-anchor">#</a> 1.浮动和清除浮动</h3> <p>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留</p> <ol><li>对父级设置适合<code>css</code>高度</li> <li><code>clear:both/float</code>清除浮动:这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签</li> <li>父级div定义 <code>overflow:hidden</code>：给包含浮动元素的父标签添加css属性<code>overflow:auto; zoom:1;</code> zoom:1用于兼容IE6</li> <li>使用after伪对象清除浮动:<code>:after{ content:&quot;.&quot;;height:0;visibility:hidden;display:block;clear:both;}</code></li></ol> <h3 id="_2-css-选择符有哪些"><a href="#_2-css-选择符有哪些" class="header-anchor">#</a> 2.CSS 选择符有哪些</h3> <ol><li>id选择器（ # myid）</li> <li>类选择器（.myclassname）</li> <li>标签选择器 （div,h2）</li> <li>相邻选择器 （h1 + p）</li> <li>子选择器（ul &gt; li）</li> <li>后代选择器（li a）</li> <li>通配符选择器（ * ）</li> <li>属性选择器（a[rel = &quot;external&quot;]）</li> <li>伪类选择器（a: hover, li:nth-child）</li></ol> <p><strong>优先级为:</strong></p> <p>！important &gt; id &gt; class &gt; tag</p> <h3 id="_3-css3中新添加的特性"><a href="#_3-css3中新添加的特性" class="header-anchor">#</a> 3.CSS3中新添加的特性</h3> <ul><li>媒体查询</li> <li>transform，transition，translate,scale,skelw，rotate等相关动画效果</li> <li>box-shadow,text-shadow等特效</li> <li>CSS3 @font-face 规则,设计师可以引入任意的字体了</li> <li>CSS3 @keyframes 规则，可以自己创建一些动画等</li> <li>2D、3D转换</li> <li>添加了border-radius，border-image等属性</li> <li>CSS3 创建多列（column-count规定文本可以以几列的方式布局）</li> <li>CSS3 用户界面（resize，box-sizing，outline-offset）</li></ul> <h3 id="_4-canvas性能优化"><a href="#_4-canvas性能优化" class="header-anchor">#</a> 4.canvas性能优化</h3> <ul><li>离屏渲染：离屏渲染就可以让我们先把图片裁剪成想要的尺寸内容保存起来</li> <li>分层画布：多个相互重叠的canvas根据变化程度分开渲染，越复杂的场景越适合</li> <li>一次性绘制：绘制操作的性能开销较高，可以创建一个包含所有线条的路径，然后通过单个绘制路径调用进行绘制</li> <li>使用 <code>requestAnimationFrame</code> 执行动画：canvas 动画的本质是不断地擦除和重绘，在运行时浏览器会自动优化方法的调用，节省系统资源，提高系统性能。</li> <li>清空画布：<code>context.fillRect()、context.clearRect()、canvas.width = canvas.width;</code></li> <li>减少调用 canvas 的 api</li></ul> <h3 id="_5-什么是bfc，可以解决什么问题"><a href="#_5-什么是bfc，可以解决什么问题" class="header-anchor">#</a> 5.什么是BFC，可以解决什么问题</h3> <p>BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干</p> <ol><li>避免margin重叠</li> <li>自适应两栏布局</li> <li>清楚浮动</li></ol> <blockquote><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</p></blockquote> <h3 id="_6-css实现一个三角形"><a href="#_6-css实现一个三角形" class="header-anchor">#</a> 6.css实现一个三角形</h3> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.triangle</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">border-top</span><span class="token punctuation">:</span> 50px solid black<span class="token punctuation">;</span>
    <span class="token property">border-right</span><span class="token punctuation">:</span> 50px solid red<span class="token punctuation">;</span>
    <span class="token property">border-bottom</span><span class="token punctuation">:</span> 50px solid green<span class="token punctuation">;</span>
    <span class="token property">border-left</span><span class="token punctuation">:</span> 50px solid blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.triangle</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 50px solid transparent<span class="token punctuation">;</span>
    <span class="token property">border-top-color</span><span class="token punctuation">:</span> black <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="三、javascript"><a href="#三、javascript" class="header-anchor">#</a> 三、javaScript</h2> <h3 id="_1-xml和-json的区别"><a href="#_1-xml和-json的区别" class="header-anchor">#</a> 1.XML和 JSON的区别</h3> <p>​	(1).数据体积方面。 JSON相对于XML来讲，数据的体积小，传递的速度更快些。</p> <p>​    (2).数据交互方面。 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</p> <p>​    (3).数据描述方面。 JSON对数据的描述性比XML较差。</p> <p>​    (4).输速度方面。 JSON的速度要远远快于XML。</p> <h3 id="_2-作用域链的理解"><a href="#_2-作用域链的理解" class="header-anchor">#</a> 2.作用域链的理解</h3> <p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 <code>window</code> 对象即被终止，作用域链向下访问变量是不被允许的。</p> <h3 id="_3-创建ajax过程"><a href="#_3-创建ajax过程" class="header-anchor">#</a> 3.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/200915.html" target="_blank" rel="noopener noreferrer">创建ajax过程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <p>(1) 创建XMLHttpRequest对象,也就是创建一个异步调用对象</p> <p>(2) 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p> <p>(3) 设置响应HTTP请求状态变化的函数</p> <p>(4) 发送HTTP请求</p> <p>(5) 获取异步调用返回的数据</p> <p>(6) 使用JavaScript和DOM实现局部刷新</p> <h3 id="_4-对前端模块化的认识"><a href="#_4-对前端模块化的认识" class="header-anchor">#</a> 4.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/200420.html" target="_blank" rel="noopener noreferrer">对前端模块化的认识<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ol><li>AMD 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化产出。</li> <li>CMD 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</li></ol> <p><code>AMD</code> 是提前执行， <code>CMD</code> 是延迟执行。</p> <p><code>AMD</code> 推荐的风格通过返回一个对象做为模块对象， <code>CommonJS</code> 的风格通过对 <code>module.exports</code> 或 <code>exports</code> 的属性赋值来达到暴露模块对象的目的。</p> <p><strong>common.js和es6模块引入的区别</strong></p> <p><strong>common.js</strong>：</p> <ul><li>require()生成一个对象，只会加载一次，会被缓存，这个对象是module.exports属性的一个拷贝。模块内部的变化相互不反映。可以实现条件加载</li> <li>在服务端运行时同步阻塞加载，在浏览器中需要提前编译打包</li></ul> <p><strong>es6</strong> :</p> <ul><li>编译时加载，代码静态解析阶段就会生成，所以不能实现条件加载（使用import()函数可以实现）</li> <li>模块输出的是一个引用，并且不会缓存值，模块内部的变化会相互反应</li></ul> <h3 id="_5-javascript垃圾回收方法"><a href="#_5-javascript垃圾回收方法" class="header-anchor">#</a> 5.Javascript垃圾回收方法</h3> <ul><li><strong>标记清除（mark and sweep）</strong></li></ul> <p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p> <p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p> <ul><li><strong>引用计数(reference counting)</strong></li></ul> <p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p> <p>在IE中虽然 <code>JavaScript</code> 对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及 <code>BOM</code> 及DOM就会出现循环引用问题。</p> <h3 id="_6-栈和队列、栈和堆的区别"><a href="#_6-栈和队列、栈和堆的区别" class="header-anchor">#</a> 6.栈和队列、栈和堆的区别</h3> <p>​	<code>栈和队列的区别:</code></p> <ul><li>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</li> <li>队列先进先出，栈先进后出。</li> <li>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</li></ul> <p><code>栈和堆的区别:</code></p> <ul><li>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。</li> <li>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。</li> <li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</li> <li>栈（数据结构）：一种先进后出的数据结构。</li></ul> <h3 id="_7-快速排序的思想并实现一个快排"><a href="#_7-快速排序的思想并实现一个快排" class="header-anchor">#</a> 7.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/200923.html" target="_blank" rel="noopener noreferrer">快速排序的思想并实现一个快排<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <p>&quot;快速排序&quot;的思想很简单，整个排序过程只需要三步：</p> <ol><li>在数据集之中，找一个基准点</li> <li>建立两个数组，分别存储左边和右边的数组</li> <li>利用递归进行下次比较</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">jsQuickSort</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> array<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> pivotIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> pivot <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>pivotIndex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//从数组中取出我们的&quot;基准&quot;元素</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//left 存放比 pivot 小的元素</span>
            left<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">//right 存放大于或等于 pivot 的元素</span>
            right<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//至此，我们将数组分成了left和right两个部分</span>
    <span class="token keyword">return</span> <span class="token function">jsQuickSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>pivot<span class="token punctuation">,</span> <span class="token function">jsQuickSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//分而治之</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">121</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">jsQuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="_8-javascript对象的几种创建方式"><a href="#_8-javascript对象的几种创建方式" class="header-anchor">#</a> 8.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/200901.html#_1-%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener noreferrer">javascript对象的几种创建方式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ol><li><p>工厂模式</p></li> <li><p>构造函数模式</p></li> <li><p>原型模式</p></li> <li><p>组合使用构造函数和原型模式</p></li> <li><p>动态原型模式</p></li> <li><p>寄生构造函数模式</p></li> <li><p>稳妥构造函数模式</p></li></ol> <h3 id="_9-javascript继承的6种方法"><a href="#_9-javascript继承的6种方法" class="header-anchor">#</a> 9.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/200901.html#_1-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener noreferrer">javascript继承的6种方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ol><li>原型链继承</li> <li>借用构造函数继承</li> <li>组合继承(原型+借用构造)</li> <li>原型式继承</li> <li>寄生式继承</li> <li>寄生组合式继承</li></ol> <h3 id="_10-闭包的理解"><a href="#_10-闭包的理解" class="header-anchor">#</a> 10.闭包的理解</h3> <p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p> <ol><li>函数嵌套函数</li> <li>函数内部可以引用外部的参数和变量</li> <li>参数和变量不会被垃圾回收机制回收</li></ol> <h3 id="_11-cookie-和session-的区别"><a href="#_11-cookie-和session-的区别" class="header-anchor">#</a> 11.cookie 和session 的区别</h3> <ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li> <li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 。考虑到安全应当使用session</li> <li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li> <li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</li> <li>将登陆信息等重要信息存放为SESSION / 其他信息如果需要保留，可以放在COOKIE中</li></ol> <h3 id="_12-virtual-dom-的优势在哪里"><a href="#_12-virtual-dom-的优势在哪里" class="header-anchor">#</a> 12.Virtual Dom 的优势在哪里</h3> <p><strong>什么是Virtual Dom</strong></p> <ul><li>DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）。</li> <li>JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化。</li> <li>引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。</li></ul> <p><strong>VDOM 和真实 DOM 的区别和优化</strong>：</p> <ul><li>虚拟 DOM 不会立马进行排版与重绘操作</li> <li>虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗</li> <li>虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部</li></ul> <h3 id="_13-node中的进程与线程"><a href="#_13-node中的进程与线程" class="header-anchor">#</a> 13.Node中的进程与线程</h3> <p>Node.js 中的进程 Process 是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息。Node.js 中进程可以使用 child_process 模块创建。</p> <p><code>关系</code>：</p> <ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）</li> <li>同一进程的所有线程共享该进程的所有资源</li> <li>进程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步</li> <li>处理机分给线程，即真正在处理机上运行的是线程</li> <li>线程是指进程内的一个执行单元，也是进程内的可调度实体</li></ul> <p><code>区别</code>：</p> <ul><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li> <li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源</li></ul> <h3 id="_14-隐式类型转换"><a href="#_14-隐式类型转换" class="header-anchor">#</a> 14.隐式类型转换</h3> <p><strong>显性转换</strong></p> <p>当我们用 Number() 等函数的时候，就是显式类型转换，其转换规则是当是基本类型时，参照规范中的对应表进行转换，当不是基本类型的时候，先参照规范中的 <code>ToPrimitive</code> 方法转换为基本类型，再按照对应表转换，当执行<code>ToPrimitive</code>的时候，又会根据情况不同，判断先执行对象的 valueOf 方法还是 toString 方法进行准换。</p> <p><strong>隐形转换</strong></p> <p>而当我们进行运算的时候，经常发生的就是隐式类型转换，比如 <code>+</code> 和 <code>==</code> 运算符，当 + 运算符的时候，更倾向于转成字符串，而当 <code>==</code> 的时候，更倾向于转为数字</p> <h3 id="_15-判断-js-类型的方式"><a href="#_15-判断-js-类型的方式" class="header-anchor">#</a> 15.判断 js 类型的方式</h3> <ol><li><code>typeof</code>:可以判断出'string','number','boolean','undefined','symbol',但判断 typeof(null) 时值为 'object'; 判断数组和对象时值均为 'object'</li> <li><code>instanceof</code></li> <li><code>Object.prototype.toString.call()</code></li> <li><code>Array.isArray()</code>:用于判断是否为数组</li></ol> <h3 id="_16-浏览器与node的事件循环有何区别"><a href="#_16-浏览器与node的事件循环有何区别" class="header-anchor">#</a> 16.浏览器与Node的事件循环有何区别</h3> <p>浏览器和 Node 环境下，microtask 任务队列的执行时机不同</p> <ul><li>Node 端，microtask 在事件循环的各个阶段之间执行</li> <li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul> <h3 id="_17-前端性能优化"><a href="#_17-前端性能优化" class="header-anchor">#</a> 17.前端性能优化</h3> <ul><li>网络篇：webpack性能调优与Gzip</li> <li>网络篇：图片优化</li> <li>存储篇：浏览器的缓存机制与缓存策略</li> <li>存储篇：本地存储Cookie到Web Storage、IndexedDB</li> <li>CND缓存与回源机制</li> <li>渲染篇：服务器渲染</li> <li>渲染篇：浏览器背后的的运行机制</li> <li>渲染篇：DOM的优化原理</li> <li>渲染篇：EventLoop与异步更新</li> <li>渲染篇：回流与重绘</li> <li>应用篇：优化首屏 - Lazy-Load</li> <li>应用篇：事件的节流和防抖</li> <li>性能检测篇：Performance、LightHouse 与性能 API</li></ul> <h3 id="_18-es6特性"><a href="#_18-es6特性" class="header-anchor">#</a> 18.ES6特性</h3> <ul><li>类：让JavaScript的面向对象编程变得更加简单和易于理解</li> <li>模块化：<code>export</code>和<code>import</code></li> <li>箭头函数：<code>() =&gt; {}</code></li> <li>函数参数默认值: <code>function (a=1) {}</code></li> <li>模板字符串: <code>${}</code></li> <li>解构赋值: <code>(a,b)={a:1, a:2}</code></li> <li>延展操作符: <code>[... ]</code></li> <li>对象属性简写</li> <li>Promise</li> <li>Let与Const: <code>const</code>与<code>let</code>都是块级作用域</li></ul> <h3 id="_19-promise内部实现原理"><a href="#_19-promise内部实现原理" class="header-anchor">#</a> 19.Promise内部实现原理</h3> <ul><li><p>触发回调的<code>triggerReject/triggerResolve</code>做的事情主要两个</p> <ol><li>更新当前状态
2. 执行回调队列中的事件</li></ol></li> <li><p>then 的实现</p></li></ul> <p>该方法为Promise实例上的方法，作用是为Promise实例增加状态改变时的回调函数。接受两个参数，resolve和reject即我们所谓成功和失败回调，其中reject可选。</p> <p>then方法返回的是一个新的实例(也就是新建了一个Promise实例)，可实现链式调用</p> <ul><li>catch 的实现</li></ul> <p>catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p> <ul><li>Promise.resolve/Promise.reject</li></ul> <p>该方法为获取一个指定状态的Promise对象的快捷操作</p> <h2 id="四、http"><a href="#四、http" class="header-anchor">#</a> 四、http</h2> <h3 id="_1-tcp传输的三次握手四次挥手策略"><a href="#_1-tcp传输的三次握手四次挥手策略" class="header-anchor">#</a> 1.TCP传输的三次握手四次挥手策略</h3> <p>为了准确无误地把数据送达目标处， <code>TCP</code> 协议采用了三次握手策略。用TCP协议把数据包送出去后， <code>TCP</code> 不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志： <code>SYN</code> 和 <code>ACK</code> 。</p> <p><code>“三次握手”:</code></p> <ul><li>发送端首先发送一个带 <code>SYN</code> 标志的数据包给对方。</li> <li>接收端收到后，回传一个带有 <code>SYN/ACK</code> 标志的数据包以示传达确认信息</li> <li>发送端再回传一个带 <code>ACK</code> 标志的数据包，代表“握手”结束。</li></ul> <p>若在握手过程中某个阶段莫名中断， <code>TCP</code> 协议会再次以相同的顺序发送相同的数据包。</p> <p><code>“四次握手”:</code></p> <ul><li>第一次挥手：主动关闭方发送一个 <code>FIN</code> ，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</li> <li>第二次挥手：被动关闭方收到 <code>FIN</code> 包后，发送一个 <code>ACK</code> 给对方，确认序号为收到序号 <code>+1</code> （与 <code>SYN</code> 相同，一个 <code>FIN</code> 占用一个序号）。</li> <li>第三次挥手：被动关闭方发送一个 <code>FIN</code> ，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li> <li>第四次挥手：主动关闭方收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li></ul> <h3 id="_2-tcp和udp的区别"><a href="#_2-tcp和udp的区别" class="header-anchor">#</a> 2.TCP和UDP的区别</h3> <p><code>TCP</code> （Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 <code>TCP</code> 连接必须要经过三次“对话”才能建立起来</p> <p><code>UDP</code> （User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p> <h3 id="_3-web-worker-和websocket"><a href="#_3-web-worker-和websocket" class="header-anchor">#</a> 3.Web  Worker 和webSocket</h3> <p><code>worker</code>主线程:</p> <ol><li>通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例</li> <li>通过worker.postMessage( data ) 方法来向worker发送数据</li> <li>绑定worker.onmessage方法来接收worker发送过来的数据</li> <li>可以使用 worker.terminate() 来终止一个worker的执行</li></ol> <p><code>WebSocket:</code></p> <p><strong>WebSocket</strong>是 <code>Web</code> 应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个 <code>Html5</code> 协议， <code>WebSocket</code> 的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。</p> <h3 id="_4-http和https"><a href="#_4-http和https" class="header-anchor">#</a> 4.HTTP和HTTPS</h3> <p><code>HTTP</code> 协议通常承载于TCP协议之上，在 <code>HTTP</code> 和 <code>TCP</code> 之间添加一个安全协议层（ <code>SSL</code> 或 <code>TSL</code> ），这个时候，就成了我们常说的HTTPS。</p> <p>默认HTTP的端口号为80， <code>HTTPS</code> 的端口号为443。</p> <h3 id="_5-为什么-https-安全"><a href="#_5-为什么-https-安全" class="header-anchor">#</a> 5. 为什么 HTTPS 安全</h3> <p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用 <code>HTTPS</code> ，密钥在你和终点站才有。 <code>https</code> 之所以比 <code>http</code> 安全，是因为他利用 <code>ssl/tls</code> 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p> <h3 id="_6-什么是etag"><a href="#_6-什么是etag" class="header-anchor">#</a> 6.什么是Etag</h3> <p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。</p> <p>情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 <code>200 OK</code> (from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</p> <p>情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和 <code>Etag</code>。然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据 <code>Etag</code> ，判断文件内容自上一次请求之后，有没有发生变化</p> <ul><li>若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发 <code>index.html</code> 的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— <code>304 Not Modified</code> ，此时浏览器就会从本地缓存中获取 <code>index.html</code> 的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。</li> <li>若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①</li></ul> <h3 id="_7-expires和cache-control"><a href="#_7-expires和cache-control" class="header-anchor">#</a> 7.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/201010.html#_1-expires" target="_blank" rel="noopener noreferrer">Expires和Cache-Control<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <p><code>Expires</code> 要求客户端和服务端的时钟严格同步。 <code>HTTP1.1</code> 引入 <code>Cache-Control</code>来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p> <h3 id="_8-http-2-0"><a href="#_8-http-2-0" class="header-anchor">#</a> 8.Http 2.0</h3> <ol><li><code>HTTP/2</code> 引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</li> <li><code>HTTP/2</code> 提供更多的加密支持</li> <li><code>HTTP/2</code> 使用多路复用，允许多个消息在一个连接上同时交差</li> <li>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的 <code>header</code> 都只会占用很小比例的带宽</li></ol> <h3 id="_9-http状态码"><a href="#_9-http状态码" class="header-anchor">#</a> 9.HTTP状态码</h3> <ul><li>200   OK    正常返回信息</li> <li>201    Created    请求成功并且服务器创建了新的资源</li> <li>202    Accepted  服务器已接受请求，但尚未处理</li> <li>301    Moved Permanently    请求的网页已永久移动到新位置</li> <li>302    Found    临时性重定向</li> <li>303    See Other    临时性重定向，且总是使用 GET 请求新的 URI</li> <li>304    Not Modified    自从上次请求后，请求的网页未修改过</li> <li>400    Bad Request    服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li> <li>401    Unauthorized    请求未授权</li> <li>403    Forbidden  禁止访问</li> <li>404    Not Found    找不到如何与 URI 相匹配的资源</li> <li>500    Internal Server Error    最常见的服务器端错误</li> <li>503    Service Unavailable   服务器端暂时无法处理请求（可能是过载或维护）</li></ul> <h3 id="_10-如何解决跨域问题"><a href="#_10-如何解决跨域问题" class="header-anchor">#</a> 10.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/201015.html" target="_blank" rel="noopener noreferrer">如何解决跨域问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ul><li><strong>JSONP</strong></li></ul> <p><code>JSONP</code> ： <code>json+padding</code> （内填充），顾名思义，就是把JSON填充到一个盒子里</p> <p>原理是：动态插入 <code>script</code> 标签，通过 <code>script</code> 标签引入一个 <code>js</code> 文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的 <code>json</code> 数据作为参数传入。</p> <p>由于同源策略的限制， <code>XmlHttpRequest</code> 只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过 <code>script</code> 标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p> <p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p> <ul><li><strong>CORS</strong></li></ul> <p>服务器端对于 <code>CORS</code> 的支持，主要就是通过设置 <code>Access-Control-Allow-Origin</code> 来进行的。如果浏览器检测到相应的设置，就可以允许 <code>Ajax</code> 进行跨域的访问。</p> <ul><li><strong>通过修改document.domain来跨子域</strong></li></ul> <p>将子域和主域的 <code>document.domain</code> 设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用 <code>document.domain</code> 进行跨域</p> <ul><li><strong>window.name()/window.postMessage()</strong></li></ul> <p><code>window</code> 对象有个 <code>name</code> 属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 <code>window.name</code> 的，每个页面对 <code>window.name</code> 都有读写的权限， <code>window.name</code> 是持久存在一个窗口载入过的所有页面中的</p> <p>使用<code>HTML5</code>中新引进的 <code>window.postMessage</code> 方法来跨域传送数据</p> <h3 id="_11-一个-tcp-连接能发几个-http-请求"><a href="#_11-一个-tcp-连接能发几个-http-请求" class="header-anchor">#</a> 11. 一个 tcp 连接能发几个 http 请求</h3> <p>如果是HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP连接即会断开，因此一个TCP发送一个HTTP请求，但是有一种情况可以将一条TCP连接保持在活跃状态，那就是通过<code>Connection</code>和<code>Keep-Alive</code>首部，在请求头带上<code>Connection: Keep-Alive</code> ，并且可以通过<code>Keep-Alive</code> 通用首部中指定的，用逗号分隔的选项调节keep-alive的行为。</p> <p>而如果是HTTP 1.1 版本协议，支持了长连接，因此只要TCP连接不断开，便可以一直发送HTTP请求，持续不断，没有上限；
同样，如果是HTTP 2.0 版本协议，支持多用复用，一个TCP连接是可以并发多个HTTP请求的，同样也是支持长连接，因此只要不断开TCP的连接，HTTP请求数也是可以没有上限地持续发送。</p> <h3 id="_12-怎么与服务端保持连接"><a href="#_12-怎么与服务端保持连接" class="header-anchor">#</a> 12.怎么与服务端保持连接</h3> <ul><li>第一种是服务端保持连接，最简单粗暴的方法就是通过请求轮询保持跟服务端的通信，客户端不光要花成本维护定时轮询器，还会使得服务器压力变大，所以不推荐</li> <li>另一种可以借助请求超时的设置，将超时时间设置一个足够大的值，客户端发起连接后，只要服务端不返回消息，整个连接阶段都会受到阻塞，所以这种方式也不推荐</li> <li>最后一种是WebSocket，当服务器完成协议从HTTP到WebSocket的升级后，服务端可以主动推送信息给客户端，解决了轮询造成的同步延迟问题。由于 WebSocket 只需要一次 HTTP 握手，服务端就能一直与客户端保持通信，直到关闭连接，这样就解决了服务器需要反复解析 HTTP 协议，减少了资源的开销。</li></ul> <h3 id="_13-tcp有哪些手段保证可靠交付"><a href="#_13-tcp有哪些手段保证可靠交付" class="header-anchor">#</a> 13.TCP有哪些手段保证可靠交付</h3> <ol><li><strong>将数据截断为合理的长度</strong>：应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。</li> <li><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li> <li><strong>对于收到的请求，给出确认响应</strong>：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。(之所以推迟，可能是要对包做完整校验)</li> <li><strong>校验出包有错，丢弃报文段，不给出响应，TCP发送数据端，超时时会重发数据</strong>：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。 如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</li> <li><strong>对失序数据进行重新排序，然后才交给应用层</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。 如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</li> <li><strong>对于重复数据，能够丢弃重复数据</strong>：既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。</li> <li><strong>TCP还能提供流量控制</strong>：CP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ol> <h3 id="_14-web如何应对流量劫持"><a href="#_14-web如何应对流量劫持" class="header-anchor">#</a> 14.Web如何应对流量劫持</h3> <ol><li>限制网站权限
<ul><li>提升网站 防 SQL 注入功</li> <li>配置 Web 站点文件夹及其操作权限</li> <li>定期清理 Web 网点中存在的可疑文件</li></ul></li> <li>使用公共114DNS
<ul><li><code>HttpDNS</code>，防止 DNS 劫持</li> <li>HTTPS 防劫持</li></ul></li></ol> <h3 id="_15-jwt的优缺点"><a href="#_15-jwt的优缺点" class="header-anchor">#</a> 15.JWT的优缺点</h3> <ul><li><p>好处</p> <ol><li><strong>支持跨域访问</strong>: Cookie是不允许垮域访问的，token支持
2. <strong>无状态</strong>： token无状态，session有状态的
3. <strong>去耦</strong>: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在 你的API被调用的时候， 你可以进行Token生成调用即可
4. <strong>更适用于移动应用</strong>: Cookie不支持手机端访问的
5. <strong>性能</strong>: 在网络传输的过程中，性能更好
6. <strong>基于标准化</strong>: 你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在 多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如： Firebase,Google, Microsoft）</li></ol></li> <li><p>缺点</p></li></ul> <ol><li><strong>占带宽</strong>：正常情况下要比 session_id 更大，需要消耗更多流量，挤占更多带宽</li> <li>无法在服务端<strong>注销</strong>，那么久很难解决劫持问题</li> <li><strong>性能问题</strong>：JWT 的卖点之一就是加密签名，由于这个特性，接收方得以验证 JWT 是否有效且被信任。但是大多数 Web 身份认证应用中，JWT 都会被存储到 Cookie 中，这就是说你有了两个层面的签名。听着似乎很牛逼，但是没有任何优势，为此，你需要花费两倍的 CPU 开销来验证签名。对于有着严格性能要求的 Web 应用，这并不理想，尤其对于单线程环境。</li></ol> <h2 id="五、browser"><a href="#五、browser" class="header-anchor">#</a> 五、browser</h2> <h3 id="_1-浏览器兼容问题"><a href="#_1-浏览器兼容问题" class="header-anchor">#</a> 1.浏览器兼容问题</h3> <ul><li><strong>渐进增强</strong>：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li> <li><strong>优雅降级</strong>：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul> <h3 id="_2-常见web安全及防护原理"><a href="#_2-常见web安全及防护原理" class="header-anchor">#</a> 2.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/200520.html" target="_blank" rel="noopener noreferrer">常见web安全及防护原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ul><li>跨网站脚本攻击（XSS）</li> <li>跨站请求伪造(CSRF)</li></ul> <p><code>XSS</code> 是获取信息，不需要提前知道其他用户页面的代码和数据包。 <code>CSRF</code> 是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</p> <h3 id="_3-列举ie-与其他浏览器不一样的特性"><a href="#_3-列举ie-与其他浏览器不一样的特性" class="header-anchor">#</a> 3.列举IE 与其他浏览器不一样的特性</h3> <ul><li>IE支持 <code>currentStyle</code> ，Firefox使用 <code>getComputStyle</code></li> <li>IE 使用 <code>innerText</code> ，Firefox使用 <code>textContent</code></li> <li>滤镜方面：IE: <code>filter:alpha(opacity= num)</code> ；Firefox： <code>-moz-opacity:num</code></li> <li>事件方面：IE： <code>attachEvent</code> ：火狐是 <code>addEventListener</code></li> <li>鼠标位置：IE是 <code>event.clientX</code> ；火狐是 <code>event.pageX</code></li> <li>IE使用 <code>event.srcElement</code> ；Firefox使用 <code>event.target</code></li> <li>IE中消除list的原点仅需<code>margin:0</code>即可达到最终效果；Firefox需要设置 <code>margin:0;padding:0以及list-style:none</code></li> <li>CSS圆角：ie7以下不支持圆角</li></ul> <h3 id="_4-浏览器的线程有哪些"><a href="#_4-浏览器的线程有哪些" class="header-anchor">#</a> 4.浏览器的线程有哪些</h3> <ul><li>GUI渲染线程</li> <li>JS引擎线程</li> <li>事件触发线程</li> <li>定时触发器线程</li> <li>异步http请求线程</li></ul> <h3 id="_5-如何加快首屏渲染"><a href="#_5-如何加快首屏渲染" class="header-anchor">#</a> 5.如何加快首屏渲染</h3> <ul><li>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyload</li> <li>加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发</li> <li>增加缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage、PWA</li> <li>渲染优化：首屏内容最小化，JS/CSS优化，加载顺序，服务端渲染，pipeline</li></ul> <h3 id="_6-输入url后发生了什么"><a href="#_6-输入url后发生了什么" class="header-anchor">#</a> 6.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/201020.html" target="_blank" rel="noopener noreferrer">输入url后发生了什么<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ol><li>DNS解析</li> <li>TCP链接</li> <li>HTTP请求与响应</li> <li>HTML词法、语法解析</li> <li>屏幕绘制</li> <li>断开连接</li></ol> <h3 id="_7-性能优化从哪些方面入手"><a href="#_7-性能优化从哪些方面入手" class="header-anchor">#</a> 7.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2020/201003.html#%E4%B8%80%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" target="_blank" rel="noopener noreferrer">性能优化从哪些方面入手<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ul><li>分屏加载，当页面需要渲染的数据较多时，先渲染首屏，下滑时再加载第二屏的数据</li> <li>图片大小优化，在不影响视觉效果的前提下，把图片尺寸降到最小</li> <li>图片懒加载，on appear时再加载图片</li> <li>Code splitting，或者拆包，应用下的某些组件不需要立刻import，可以采用动态import的方式，打包时也可以将它们打到不同的bundle里，给index bundle瘦身</li> <li>Chrome Devtools - Trace &amp; Timeline等一系列强大的分析工具可以去研究一下，它们可以深入到内核分析应用的性能问题所在</li></ul> <h2 id="六、vue"><a href="#六、vue" class="header-anchor">#</a> 六、Vue</h2> <h3 id="_1-vue-双向绑定原理"><a href="#_1-vue-双向绑定原理" class="header-anchor">#</a> 1.Vue 双向绑定原理</h3> <p>Vue双向绑定采用<strong>数据劫持结合发布者-订阅者模式</strong>的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p> <ol><li>需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li> <li>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li> <li>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</li></ol> <ul><li>在自身实例化时往属性订阅器(dep)里面添加自己</li> <li>自身必须有一个 update() 方法</li> <li>待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退</li></ul> <ol start="4"><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过Observer来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</li></ol> <h3 id="_2-vue-的响应式系统"><a href="#_2-vue-的响应式系统" class="header-anchor">#</a> 2.Vue 的响应式系统</h3> <ul><li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例</li> <li>Vue 的 data 上的属性会被添加 getter 和 setter 属性</li> <li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li> <li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新</li></ul> <h3 id="_3-虚拟-dom-实现原理"><a href="#_3-虚拟-dom-实现原理" class="header-anchor">#</a> 3.虚拟 DOM 实现原理</h3> <ul><li>虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象</li> <li>状态变更时，记录新树和旧树的差异</li> <li>最后把差异更新到真正的dom中</li></ul> <h3 id="_4-vue-首屏加载优化"><a href="#_4-vue-首屏加载优化" class="header-anchor">#</a> 4.vue 首屏加载优化</h3> <ol><li>把不常改变的库放到 index.html 中，通过 cdn 引入</li> <li>vue 路由的懒加载</li> <li>不生成 map 文件</li> <li>vue 组件尽量不要全局引入</li> <li>使用更轻量级的工具库</li> <li>开启gzip压缩</li> <li>首页单独做服务端渲染</li></ol> <h3 id="_5-vue的生命周期"><a href="#_5-vue的生命周期" class="header-anchor">#</a> 5.vue的生命周期</h3> <ul><li>beforeCreate</li> <li>created</li> <li>beforeMount</li> <li>mounted</li> <li>beforeUpdate</li> <li>updated</li> <li>beforeDestroy</li> <li>destroyed</li></ul> <ol><li>beforeCreate执行时：data和el均未初始化，值为undefined</li> <li>created执行时：Vue 实例观察的数据对象data已经配置好，已经可以得到data的值，但Vue 实例使用的根 <code>DOM 元素el</code> 还未初始化</li> <li>beforeMount执行时：data和el均已经初始化，但此时el并没有渲染进数据，el的值为“虚拟”的元素节点</li> <li>mounted执行时：此时el已经渲染完成并挂载到实例上</li> <li>beforeUpdate和updated触发时，el中的数据都已经渲染完成，但只有updated钩子被调用时候，组件dom才被更新</li> <li>在created钩子中可以对data数据进行操作，这个时候可以进行数据请求将返回的数据赋给data</li> <li>在mounted钩子对挂载的dom进行操作，此时，DOM已经被渲染到页面上</li> <li>虽然updated函数会在数据变化时被触发，但却不能准确的判断是那个属性值被改变，所以在实际情况中用<strong>computed</strong>或<strong>watch</strong>函数来监听属性的变化，并做一些其他的操作</li> <li>在使用vue-router时有时需要使用来缓存组件状态，这个时候created钩子就不会被重复调用了，如果我们的子组件需要在每次加载或切换状态的时候进行某些操作，可以使用activated钩子触发</li> <li><strong>父子组件的钩子并不会等待请求返回，请求是异步的，VUE设计也不能因为请求没有响应而不执行后面的钩子。所以，我们必须通过v-if来控制子组件钩子的执行时机</strong></li></ol> <h3 id="_6-vue的nexttick实现原理以及应用场景"><a href="#_6-vue的nexttick实现原理以及应用场景" class="header-anchor">#</a> 6.vue的nextTick实现原理以及应用场景</h3> <p><strong>实现原理</strong>：</p> <p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和<code>MessageChannel</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code>代替。</p> <p>例如，当你设置<code>vm.someData = 'new value'</code>，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用<code>Vue.nextTick(callback)</code> 。这样回调函数在 DOM 更新完成后就会调用。</p> <p><strong>应用场景</strong>：</p> <ul><li>在Vue生命周期的<code>created()</code>钩子函数进行的DOM操作一定要放在<code>Vue.nextTick()</code>的回调函数中</li></ul> <p>在<code>created()</code>钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进<code>Vue.nextTick()</code>的回调函数中。与之对应的就是<code>mounted()</code>钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。</p> <ul><li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进<code>Vue.nextTick()</code>的回调函数中。</li></ul> <h3 id="_7-vue3-proxy解决了哪些问题"><a href="#_7-vue3-proxy解决了哪些问题" class="header-anchor">#</a> 7.Vue3 proxy解决了哪些问题</h3> <p><strong>Object.defineProperty的缺陷</strong></p> <ul><li>无法检测到对象属性的新增或删除</li> <li>不能监听数组的变化</li></ul> <p><strong>proxy</strong></p> <ul><li>Proxy直接代理整个对象而非对象属性</li> <li>Proxy也可以监听数组的变化</li></ul> <h3 id="_8-观察者模式和发布订阅模式区别"><a href="#_8-观察者模式和发布订阅模式区别" class="header-anchor">#</a> 8.观察者模式和发布订阅模式区别</h3> <p><strong>表面上</strong></p> <ul><li>观察者模式：观察者 + 被观察者</li> <li>发布订阅模式：发布者和订阅者两个角色，还有一个—— 经纪人Broker</li></ul> <p><strong>往更深层次</strong></p> <ul><li>观察者和被观察者，是松耦合的关系</li> <li>发布者和订阅者，则完全不存在耦合</li></ul> <p><strong>从使用层面上</strong></p> <ul><li>观察者模式，多用于单个应用内部</li> <li>发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件</li></ul> <h3 id="_9-父子组件生命周期执行顺序"><a href="#_9-父子组件生命周期执行顺序" class="header-anchor">#</a> 9.父子组件生命周期执行顺序</h3> <ul><li>加载渲染过程</li></ul> <blockquote><p>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p></blockquote> <ul><li>更新过程</li></ul> <blockquote><p>父beforeUpdate -&gt;子 beforeUpdate -&gt; 子updated -&gt; 父updated</p></blockquote> <ul><li>销毁过程</li></ul> <blockquote><p>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p></blockquote> <h3 id="_10-实现指令"><a href="#_10-实现指令" class="header-anchor">#</a> 10.实现指令</h3> <ul><li>通过 Vue.directive() 函数注册一个全局的指令</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'self_name'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
  <span class="token function-variable function">bind</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//do someting</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//do something</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>通过组件的 directives 属性，对该组件添加一个局部的指令</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>
  directives<span class="token operator">:</span><span class="token punctuation">{</span>
    self_defined_name1<span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function-variable function">bind</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token comment">//do something</span>
        <span class="token punctuation">}</span>
        <span class="token function-variable function">inserted</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                  <span class="token comment">//do something</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">}</span>

    self_defined_name2<span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function-variable function">bind</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token comment">//do something</span>
        <span class="token punctuation">}</span>
        <span class="token function-variable function">inserted</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span>binding</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                  <span class="token comment">//do something</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="七、webpack"><a href="#七、webpack" class="header-anchor">#</a> 七、webpack</h2> <h3 id="_1-webpack构建流程"><a href="#_1-webpack构建流程" class="header-anchor">#</a> 1. webpack构建流程</h3> <ol><li>初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果</li> <li>开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译</li> <li>确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去</li> <li>编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li> <li>完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk</li> <li>输出完成：输出所有的chunk到文件系统</li></ol> <h3 id="_2-webpack的plugins实现原理"><a href="#_2-webpack的plugins实现原理" class="header-anchor">#</a> 2.webpack的plugins实现原理</h3> <ul><li>plugin实际是一个类（构造函数），通过在plugins配置中实例化进行调用</li> <li>它在原型对象上指定了一个apply方法，入参是compiler对象</li> <li>指定一个事件钩子，并调用内部提供的API</li> <li>完成操作后，调用webpack 提供的callback方法</li></ul> <h3 id="_3-webpack前端构建性能优化策略"><a href="#_3-webpack前端构建性能优化策略" class="header-anchor">#</a> 3.<a href="https://wangyue-1997.github.io/blog-vuepress/view/2021/210103.html" target="_blank" rel="noopener noreferrer">webpack前端构建性能优化策略<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ul><li>合理配置<code>CommonsChunkPlugin</code>：通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用</li> <li>通过<code>externals</code>配置来提取常用库： 1. 使用插件 <code>html-webpack-externals-plugin</code>  2. 直接配置 externals</li> <li>利用<code>DllPlugin</code>和<code>DllReferencePlugin</code>预编译资源模块</li> <li>使用<code>Happypack</code>加速你的代码构建： 作用就是将文件解析任务分解成多个子进程并发执行。子进程处理完任务后再将结果发送给主进程。所以可以大大提升 Webpack 的项目构件速度。<code>只作用 lodash</code></li> <li>增强<code>uglifyPlugin</code>: 压缩文件 （tree sharking）</li> <li>模块热更新: 在应用程序运行过程中替换、添加或删除模块，无需重新加载页面，极大地加速了开发时间</li></ul> <h3 id="_4-loader-与-plugins-的区别"><a href="#_4-loader-与-plugins-的区别" class="header-anchor">#</a> 4.loader 与 plugins 的区别</h3> <ul><li><p>loader: 由于 webpack 本身只能打包 commonjs 规范的js文件，所以，针对 css ，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。</p> <ul><li>css-loader 和 style-loader 模块是为了打包 css</li> <li>babel-loader 和 babel-core 模块时为了把 ES6 的代码转成 ES5</li> <li>url-loader 和 file-loader 是把图片进行打包</li></ul></li> <li><p>plugins:  plugin也是为了扩展 webpack 的功能，但是 plugin 是作用于 webpack 本身上的。而且 plugin 不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。</p> <ul><li>CommonChunkPlugin 主要用于提取第三方库和公共模块，避免首屏加载的 bundle 文件，或者按需加载的 bundle 文件体积过大，导致加载时间过长</li> <li>html-webpack-plugin 针对 html 文件打包和拷贝（还有很多设置）</li></ul></li></ul> <ol><li><p>loader 运行在打包文件之前（ loader 为在模块加载时的预处理文件）</p></li> <li><p>plugins 在整个编译周期都起作用。</p></li></ol> <h3 id="_5-常用的loader"><a href="#_5-常用的loader" class="header-anchor">#</a> 5.常用的loader</h3> <p>样式：style-loader、css-loader、less-loader、sass-loader等</p> <p>文件：raw-loader、file-loader 、url-loader等</p> <p>编译：babel-loader、coffee-loader 、ts-loader等</p> <p>校验测试：mocha-loader、jshint-loader 、eslint-loader等</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          test<span class="token operator">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span>
          use<span class="token operator">:</span><span class="token punctuation">[</span>
              <span class="token punctuation">{</span>loader<span class="token operator">:</span><span class="token string">'style-loader'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
              <span class="token punctuation">{</span>loader<span class="token operator">:</span><span class="token string">'css-loader'</span><span class="token punctuation">,</span>options<span class="token operator">:</span><span class="token punctuation">{</span>sourceMap<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>modules<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
              <span class="token punctuation">{</span>loader<span class="token operator">:</span><span class="token string">'sass-loader'</span><span class="token punctuation">,</span>options<span class="token operator">:</span><span class="token punctuation">{</span>sourceMap<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
          <span class="token punctuation">]</span><span class="token punctuation">,</span>
          exclude<span class="token operator">:</span><span class="token regex">/node_modules/</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="_6-常用的plugins"><a href="#_6-常用的plugins" class="header-anchor">#</a> 6.常用的plugins</h3> <ul><li>UglifyJsPlugin: 压缩和混淆代码</li> <li>CommonsChunkPlugin: 提高打包效率，将第三方库和业务代码分开打包</li> <li>ProvidePlugin: 自动加载模块，代替require和import</li> <li>html-webpack-plugin: 可以根据模板自动生成 html 代码，并自动引用 css 和 js 文件</li> <li>extract-text-webpack-plugin: 将 js 文件中引用的样式单独抽离成 css 文件</li> <li>HotModuleReplacementPlugin: 热更新</li> <li>optimize-css-assets-webpack-plugin: 不同组件中重复的 css 可以快速去重</li> <li>webpack-bundle-analyzer: 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示</li> <li>compression-webpack-plugin: 生产环境可采用 gzip 压缩 JS 和 CSS</li> <li>happypack: 通过多进程模型，来加速代码构建</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//installed via npm</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//to access built-in plugins</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> test<span class="token operator">:</span> <span class="token regex">/\.txt$/</span><span class="token punctuation">,</span> use<span class="token operator">:</span> <span class="token string">'raw-loader'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_7-编写-plugin"><a href="#_7-编写-plugin" class="header-anchor">#</a> 7.编写 plugin</h3> <ul><li>命名的JavaScript函数或JavaScript类</li> <li><code>apply</code>在其原型中定义方法</li> <li>指定要利用的<a href="https://webpack.js.org/api/compiler-hooks/" target="_blank" rel="noopener noreferrer">事件挂钩<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>处理webpack内部实例特定的数据</li> <li>功能完成后，调用webpack提供的回调</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// A JavaScript class.</span>
<span class="token keyword">class</span> <span class="token class-name">MyExampleWebpackPlugin</span> <span class="token punctuation">{</span>
  <span class="token comment">// Define `apply` as its prototype method which is supplied with compiler as its argument</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Specify the event hook to attach to</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>emit<span class="token punctuation">.</span><span class="token function">tapAsync</span><span class="token punctuation">(</span>
      <span class="token string">'MyExampleWebpackPlugin'</span><span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is an example plugin!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Here’s the `compilation` object which represents a single build of assets:'</span><span class="token punctuation">,</span> compilation<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Manipulate the build using the plugin API provided by webpack</span>
        compilation<span class="token punctuation">.</span><span class="token function">addModule</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="_8-scope-hoisting-作用域提升"><a href="#_8-scope-hoisting-作用域提升" class="header-anchor">#</a> 8.scope hoisting (作用域提升)</h3> <p>webpack以前使用独立的函数包装一个个模块文件，webpack3可以将所有模块连接到一个闭包里面，放入一个函数，执行速度更快，体积也会更小 。<code>scope hoisting</code> 顾名思义就是将模块的作用域提升，在 webpack 中不能将所有所有的模块直接放在同一个作用域下，有以下几个原因：</p> <ol><li>按需加载的模块</li> <li>使用 commonjs 规范的模块</li> <li>被多 entry 共享的模块</li></ol> <p>优化后：</p> <ol><li>代码量明显减少</li> <li>减少多个函数后内存占用减少</li> <li>用多次使用 <code>__webpack_require__</code> 调用模块，运行速度也会得到提升</li></ol> <h3 id="_9-tree-sharking"><a href="#_9-tree-sharking" class="header-anchor">#</a> 9. tree sharking</h3> <p><code>Tree-shaking</code> 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码。一般 dead code 具有一下的特征：</p> <ol><li>代码不会被执行，不可到达</li> <li>代码执行的结果不会被用到</li> <li>代码只会影响死变量（只写不读）</li></ol> <p>原理：</p> <ul><li>ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码</li> <li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li></ul> <h3 id="_10-热更新"><a href="#_10-热更新" class="header-anchor">#</a> 10.热更新</h3> <blockquote><p><code>Hot Module Replacement</code>，简称<code>HMR</code>，无需完全刷新整个页面的同时，更新模块。<code>HMR</code>的好处，在日常开发工作中体会颇深：<strong>节省宝贵的开发时间、提升开发体验</strong></p></blockquote> <p>Hot Module Replacement（以下简称 HMR），当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态。</p> <p>实现原理：构建 bundle 的时候，加入一段 HMR runtime 的 js 和一段和服务沟通的 js 。文件修改会触发 webpack 重新构建，服务器通过向浏览器发送更新消息，浏览器通过 jsonp 拉取更新的模块文件，jsonp 回调触发模块热替换逻辑。</p> <h2 id="八、算法"><a href="#八、算法" class="header-anchor">#</a> 八、算法</h2> <h3 id="_1-top-k问题"><a href="#_1-top-k问题" class="header-anchor">#</a> 1. top-K问题</h3> <ul><li>top-1</li> <li>top-2</li> <li>top-K</li></ul></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----></main> <!----> <div style="display:none;" data-v-319dd33c data-v-319dd33c><div class="comments-wrapper" data-v-319dd33c><!----></div></div></div></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-a81d141e data-v-a81d141e><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-a81d141e><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-a81d141e></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-a81d141e></path></svg></div></div></div>
    <script src="/blog-vuepress/assets/js/app.ad6e5f6e.js" defer></script><script src="/blog-vuepress/assets/js/3.0ace89c5.js" defer></script><script src="/blog-vuepress/assets/js/1.960ca73c.js" defer></script><script src="/blog-vuepress/assets/js/14.e482d904.js" defer></script>
  </body>
</html>
